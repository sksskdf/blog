---
title: Clean Architecture
date: 2025-12-01
---

## 서문

---

수많은 다양한 애플리케이션과 시스템들은 근본적으론 다른 것 같지만 아키텍처 규칙은 동일하다. ***소프트웨어 아키텍처의 규칙은 다른 모든 변수에 독립적***이기 때문이다. 쉽게 말해 특정 기술, 프레임워크, 데이터베이스, UI, 운영 환경 등 외부 요소에 종속되지 않고 독립적으로 설계되어야 한다는 뜻이다.

컴퓨터가 최초로 등장한 반세기 전에 비해 지금의 컴퓨터는 $10^{22}$배 강력해졌다. 이에따라 소프트웨어는 더 커졌다. 하지만 코드는 여전히 순차(sequence), 분기(selection), 반복(iteration)의 집합체로, 컴퓨터 프로그래밍을 이루는 기본 구성요소는 바뀌지 않았다.

이처럼 코드가 변하지 않았다는 사실이 시스템의 종류와 상관없이 소프트웨어 아키텍처의 규칙이 일관된 이유이다. 소프트웨어 아키텍처의 규칙이란 프로그램의 구성요소를 정렬하고 조립하는 방법에 관한 규칙이고 이 구성요소가 보편적이며 변하지 않았으므로, 이들을 정렬하는 규칙 역시도 보편적이며 변한 것이 없다.

소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는 데 투입되는 인력을 최소화하는 데 있다. 좋은 아키텍처와 설계란 이처럼 단순명료하다.

## 두 가지 가치

---

모든 소프트웨어 시스템은 이해관계자에게 행위(behavior)와 구조(structure)라는 두 가지 가치를 제공한다. 

행위는 말 그대로 기능 명세서나 요구사항 문서를 코드로 구체화하는 것을 말한다.

구조는 변경사항을 간단하고 쉽게 적용할 수 있는 아키텍처를 선택해야 한다. 변경사항에는 범위와 형태가 있는데, 아키텍처는 형태에 독립적이어야 한다. 즉 어떠한 변경사항이든 간단하고 쉽게 적용할 수 있어야 한다는 이야기이다.

결론적으로 아키텍처가 후순위가 되면 시스템을 개발하는 비용이 더 많이 들고, 일부 또는 전체 시스템에 변경을 가하는 일이 현실적으로 불가능해진다.

## 프로그래밍 패러다임과 객체 지향

---

프로그래밍 패러다임에는 크게 구조적 프로그래밍, 객체 지향 프로그래밍, 함수형 프로그래밍이 있다.

- 구조적 프로그래밍: `goto`와 같은 점프를 `if/then/else`와 `do/while/until` 과 같은 익숙한 구조로 대체하여 제어흐름의 직접적인 전환에 대한 규칙을 부과한다.
- 객체 지향 프로그래밍: 함수를 변수처럼 다룰 수 있게 해주는 함수 포인터를 통해 런타임에 어떤 함수를 호출할 지 결정하여 제어흐름의 간접적인 전환에 대해 규칙을 부과한다.
- 함수형 프로그래밍: 람다 계산법의 기초인 불변성과 심볼의 값이 변경되지 않는다는 개념을 통해 할당문에 대해 규칙을 부과한다.

세 가지 프로그래밍 패러다임은 프로그래머에게서 권한을 박탈하여 무엇을 해야 할 지 보단 무엇을 해서는 안 되는지를 말해준다.  그리고 이러한 세 가지 패러다임과 아키텍처의 큰 관심사인 함수, 컴포넌트 분리, 데이터 관리에는 연관성이 있다.

구조적 프로그래밍은 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 테스트 가능한 단위로 쪼갤 수 있게 해주며 이러한 기능적 분해를 아키텍처적 관점에서는 최고의 실천법 중 하나로 여긴다.

객체 지향 프로그래밍은 다형성과 의존성 역전을 이용해 의존성의 방향을 제어 흐름과 상관없이 설정하여 각 모듈에 대한 독립성을 보장할 수 있게 해준다. 이를 통해 플러그인 아키텍처를 구성하여 시스템의 여러 모듈을 독립적으로 개발하여 시스템의 정책과 세부사항을 구조적으로 분리할 수 있게 해준다.

그 외에 함수형 프로그래밍은 이벤트 기반 아키텍처의 기반이 된다.

## SOLID

---

좋은 소프트웨어 시스템은 깔끔한 코드로부터 시작한다. 객체 지향 프로그래밍에서 클래스는 함수와 데이터 구조를 포함하고 이러한 클래스들의 배치와 결합에 대한 방법론이 SOLID 원칙이다. SOLID 원칙은 코드 수준보다는 약간 상위에 적용되어 모듈과 컴포넌트 내부에서 사용되는 구조인 중간 수준의 구조를 변경에 유연하고 이해하기 쉽게 해준다.

`SRP(Single Responsibility Principle)`는 임의의 클래스가 오직 하나의 액터에 대한 책임을 갖게 함으로써 중복과 병합 충돌을 피하게 해준다. `SRP`는 메서드와 클래스 수준의 원칙이지만 컴포넌트와 아키텍처 수준에서도 다른 형태로 다시 등장한다. 이는 컴포넌트 수준에서는 `공통 폐쇄 원칙(Common Closure Principle)`이고 아키텍처 수준에서는 `아키텍처 경계(Architectural Boundary)`의 생성을 책임지는 `변경의 축(Axis of Change)`이 된다.

`OCP(Open Closed Principle)`는 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다는 원칙이다. 이러한 목적을 달성하려면 처리 과정 자체를 클래스 단위로 분할하여 컴포넌트 단위로 구분해야 한다. 이 때 A 컴포넌트에서 발생한 변경으로부터 B 컴포넌트를 보호하려면 반드시 A 컴포넌트가 B 컴포넌트에 의존해야 한다. 이 때 A 컴포넌트는 상대적으로 저수준 컴포넌트에 해당하고 B 컴포넌트는 고수준 컴포넌트에 해당하게 되는데, 이러한 클래스별 기능을 어떻게, 왜, 언제 발생하는지에 따라 분리하고 계층구조로 조직화하여 저수준 컴포넌트에서 발생한 변경으로부터 고수준 컴포넌트를 보호할 수 있다.

`DIP(Dependecy Inversion Principle)` 는 구체가 아닌 추상에 의존한다는 원칙이다. 변동성이 큰 구체적인 요소에 의존하지 않고 비교적 변경이 적은 추상 인터페이스에 의존하게 하여 아키텍처의 경계를 설정할 수 있다. 물론 추상 인터페이스 또한 소스 코드이기 때문에 얼마든지 변경이 가능하다 그래서 아키텍트는 인터페이스의 변동성을 낮추기 위해 노력해야 한다.

## 컴포넌트

---

SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다. 소프트웨어 시스템은 작은 컴포넌트들로 만들어진다.

컴포넌트는 배포 단위이며 시스템의 구성 요소로 배포할 수 있는 가장 작은 단위이다. 자바의 경우 `jar`, 루비에선 `gem`, 닷넷에서는 `dll`이다.

어떤 클래스를 어느 컴포넌트에 포함시켜야 할 지는 `REP(Reuse/Release Equivalence Principle)`, `CCP(Common Closure Principle)`, `CRP(Common Reuse Principle)` 이 세 가지 원칙에 따라 정한다.

## 아키텍처

---

아키텍처란 시스템을 컴포넌트로 분할하고 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통 하는 방식을 정하는 것이다. 그리고 이를 통해 소프트웨어가 쉽게 개발, 배포, 운영, 유지보수되도록 만든다.

이러한 일을 용이하게 만들기 위해서는 가능한 한 많은 선택지를 오래 남겨두어야 한다.

소프트웨어를 부드럽게 만드는 것은 구조적 가치의 이유가 크다. 애초에 소프트웨어의 탄생 의의 자체가 기계의 행위를 빠르고 쉽게 변경하는 방법이 필요했기 때문이다. 하지만 이러한 유연성은 시스템의 형태, 컴포넌트의 배치 방식, 컴포넌트가 상호 연결되는 방식에 상당히 크게 의존한다.

그리고 소프트웨어를 부드럽게 유지하는 방법은 선택사항을 가능한 많이 오랫동안 열어두는 것이고 그 선택사항은 바로 중요치 않은 `세부사항` 이다.

모든 소프트웨어 시스템은 `정책`과 `세부사항` 으로 분해할 수 있다.

정책은 모든 업무 규칙과 업무 절차를 구체화하고 시스템의 진정한 가치가 살아있는 곳이다.

세부사항은 사람, 외부 시스템, 프로그래머가 정책과 소통할 때 필요한 요소이다. 이러한 세부사항에는 입출력 장치, 데이터베이스, 웹 시스템, 서버, 프레임워크, 통신 프로토콜 등이 있다.

아키텍트의 목표는 시스템에서 정책을 가장 핵심적인 요소로 식별하고, 동시에 세부사항은 정책에 무관하게 만들 수 있는 형태의 시스템을 구축하는데 있다.

## 독립성

---

좋은 아키텍처는 선택사항을 열어 둠으로써 향후 시스템에 변경이 필요할 때 어떤 방향으로 쉽게 변경할 수 있어야 한다.

이러한 의도와 맥락에 따라 다른 이유로 변경되는 것들은 분리하고 동일한 이유로 변경되는 것들은 묶을 수 있다. 서로 다른 이유로 변경되는 예는 사용자 인터페이스와 업무 규칙이 있다.

만약 어떤 한 유스케이스에서 UI와 업무 규칙 부분을 분리할 수 있다면 두 요소를 서로 독립적으로 변경할 수 있다. 이렇게 시스템을 서로 결합되지 않은 수평적인 계층으로 분리하면 UI, 업무 규칙, DB 등으로 분리할 수 있다. 이러한 계층 분리를 계층 결합 분리라고 얘기한다.

그리고 유스케이스끼리도 독립성을 보장하여 유스케이스끼리의 결합을 분리하는 것을 유스케이스 결합 분리라고 얘기한다.

이렇게 계층 결합 분리와 유스케이스 결합 분리가 이루어진 서비스에서 결합 분리된 작업들의 이점을 살리기 위해 결합을 분리할 적절한 모드를 선택해야 한다. 단일 프로세서의 동일한 주소 공간에 함께 상주하는 형태가 될 수도 있고 독립된 서비스로써 네트워크를 통해 서로 통신할 수도 있다. 어쨌든 결합 분리 모드 역시 결정을 미룰 수 있는 선택사항이다.

그리고 이러한 독립성을 위한 분리가 제일 좋게 작용하는 지점은 바로 개발에 대한 독립성이다. 계층과 유스케이스의 결합이 분리되는 한 시스템의 아키텍처는 어떤 구조의 팀이든 그 팀 구조를 뒷받침 해줄 수 있다.

계층과 유스케이스의 결합을 분리하는 방법은 다양하다.

- 소스 수준 분리 모드: 모든 컴포넌트가 같은 주소 공간에서 실행된다. 이러한 구조를 모노리틱 구조라 부른다.
- 배포 수준 분리 모드: 많은 컴포넌트가 여전히 같은 주소 공간에 상주하지만 동일한 프로세서의 다른 프로세스에 상주하고, 프로세스간 통신, 소켓, 공유 메모리를 통해 통신한다. 결합이 분리된 컴포넌트들은 독립적으로 배포할 수 있는 단위로 분할되어 있다.
- 서비스 수준 분리 모드: 네트워크 패킷을 통해 서비스들이 통신하며 모든 실행 가능한 단위는 소스와 바이너리 변경에 대해 서로 완전히 독립적이다.

당장엔 시스템을 단일 서버(모노리틱)로도 안정되게 실행할 수 있더라도, 시스템이 성장하며 결국 별도 서버에서 실행해야만 하는 컴포넌트가 생길 거라고 충분히 예상할 수 있다.

한가지 해결책은 서비스 수준에서의 분리를 기본 정책으로 삼되, 서비스가 되기 직전에 멈추는 방식이 좋을 수 있다.

## 경계: 선 긋기

---

소프트웨어 아키텍처는 선을 긋는 기술이며 이러한 선을 경계(Boundary)라 부른다.

경계는 소프트웨어 요소를 서로 분리하고, 경계 한편에 있는 요소가 반대편에 있는 요소를 알지 못하도록 막는다. 이러한 선은 코드가 작성되기도 전에 그어지며 어떤 선은 매우 나중에 그어지기도 한다. 그리고 초기에 그어지는 선들은 가능한 한 오랫동안 결정을 연기시키기 위해 특정 결정이 핵심적인 업무 로직을 오염시키지 못하게 만드려는 목적으로 쓰인다.

아키텍트의 목표는 필요한 시스템을 만들고 유지하는 데 드는 인적 자원을 최소화하는 것이다. 하지만 너무 일찍 내려진 결정에 따른 결합(coupling)이 이러한 인적 자원의 효율을 떨어뜨린다.

관련이 있는 것과 없는 것 사이에 선을 긋는다. 그리고 이렇게 선으로 그어져 분리된 구성 요소들은 저수준 세부사항과 고수준 추상화로 나뉘고 의존성은 저수준 세부사항에서 고수준의 추상화로 향하도록 배치된다. 그리고 저수준 세부사항을 포함하는 컴포넌트는 플러그인 형태로 구성될 수 있다.

## 경계 해부학

---

시스템 아키텍처는 일련의 소프트웨어 컴포넌트와 그 컴포넌트들을 분리하는 경계에 의해 정의된다.

런타임에 이러한 경계를 횡단한다 함은 그저 경계 한쪽에 있는 기능에서 반대편 기능을 호출하여 데이터를 전달하는 일에 불과하다. 그리고 적절한 위치에서 경계를 횡단하게 하는 비결은 소스 코드 의존성 관리에 있다.

아키텍처 경계 중 가장 단순하며 흔한 형태는 물리적으로 엄격하게 구분되지 않는 형태인데, 이 형태에서는 함수와 데이터가 단일 프로세서에서 같은 주소 공간을 공유하며 그저 나름의 규칙에 따라 분리되어 있을 뿐이다. 이는 소스 수준 분리 모드라고 불리며, 배포 관점에서 보면 소위 단일체(monolith)라고 불리는 단일 실행 파일에 지나지 않는다.

배포 관점에서 볼 때 단일체는 경계가 드러나지 않지만 그렇다고 경계가 존재하지 않는 것은 아니다. 최종적으로 정적으로 링크된 단일 실행 파일을 만들더라도 그 안에 포함된 다양한 컴포넌트를 개발하고 바이너리로 만드는 과정을 독립적으로 수행할 수 있게 하는 일은 대단히 가치 있는 일이다.

이러한 아키텍처는 거의 모든 경우에 특정한 동적 다형성에 의존하여 내부 의존성을 관리하고 바로 이 때문에 최근 수십 년 동안 객체 지향 개발이 아주 중요한 패러다임이 될 수 있었다. 객체 지향이 없었다면 또는 다형성에 해당하는 메커니즘이 없었다면, 아키텍트는 결합도를 적절히 분리하기 위해 함수를 가리키는 포인터라는 위험한 옛 관행에 기대야 했을 것이다.

## 정책과 수준

---

소프트웨어 시스템이란 정책을 기술한 것이다. 실제로 컴퓨터 프로그램의 핵심은 이게 전부다. 컴퓨터 프로그램은 어떠한 입력을 출력으로 변환하는 정책을 상세하게 기술한 설명서다.

소프트웨어 아키텍처를 개발하는 기술에는 이러한 정책을 신중하게 분리하고, 정책이 변경되는 양상에 따라 정책을 재편성하는 일도 포함된다. 동일한 이유로 동일한 시점에 변경되는 정책은 동일한 수준에 위치하며, 동일한 컴포넌트에 속해야 한다.

소프트웨어 아키텍처에서의 수준이란 입력과 출력까지의 거리이다. 시스템의 입력과 출력 모두로부터 멀리 위치할수록 정책의 수준은 높아지고, 입력과 출력을 다루는 정책이라면 시스템에서 최하위 수준에 위치한다.

## 유스케이스

---

유스케이스는 사용자가 제공해야 하는 입력, 사용자에게 보여줄 출력, 그리고 해당 출력을 생성하기 위한 처리 단계를 기술한다. 유스케이스는 엔티티 내부의 핵심 업무 규칙을 어떻게, 그리고 언제 호출할지를 명시하는 규칙을 담는다. 유스케이스는 사용자 인터페이스를 기술하지 않으므로 유스케이스만 봐서는 이 애플리케이션이 웹을 통해 전달되는지, 리치 클라이언트인지, 콘솔 기반인지 구분할 수 없어야 한다.

유스케이스의 피호출자인 엔티티 역시 유스케이스에 대해 알지 못한다. 엔티티는 유스케이스에 비해 상대적으로 고수준이다.

왜 엔티티는 고수준이며, 유스케이스는 저수준일까? 왜냐하면 유스케이스는 단일 애플리케이션에 특화되어 있으며, 따라서 해당 시스템의 입력과 출력에 보다 가깝게 위치하기 때문이다. 엔티티는 수많은 다양한 애플리케이션에서 사용될 수 있도록 일반화 된 것이므로 각 시스템의 입력이나 출력에서 더 멀리 떨어져 있다. 유스케이스는 엔티티에 의존하지만 엔티티는 유스케이스에 의존하지 않는다.

## 소리치는 아키텍처

---

상위 수준의 디렉토리 구조, 최상위 패키지에 담긴 소스 파일을 볼 때 아키텍처가 시스템을 소리치는지, 프레임워크와 같은 세부사항에 대해 소리치는지는 아키텍처 구조에서 중요한 요소이다.

주택이나 도서관의 계획서가 해당 건축물의 유스케이스에 대해 소리치는 것처럼, 소프트웨어 애플리케이션의 아키텍처도 애플리케이션의 유스케이스에 대해 소리쳐야 한다.

아키텍처가 유스케이스를 최우선으로 한다면, 그리고 프레임워크와는 적당한 거리를 둔다면, 프레임워크 없이도 유스케이스 전부에 대해 단위 테스트를 할 수 있어야 한다.

## 클린 아키텍처

---

<aside>
🌠

`육각형 아키텍처(Hexagonal Architecture)` - `포트와 어댑터(Ports and Adapters)`

`DCI(Data, Context and Interaction)`

`BCE(Boundary-Control-Entity)`

이들 아키텍처는 모두 세부적인 면에서는 다소 차이가 있더라도 내용은 비슷하다.

이들 모두의 목표는 관심사의 분리(Seperation of Concerns)다.

</aside>

클린 아키텍처와 비슷한 아키텍처들이 많은데, 이들 모두 공통점은 소프트웨어를 계층으로 분리함으로써 관심사의 분리라는 목표를 달성한다.

각 아키텍처는 최소한 업무 규칙을 위한 계층 하나와, 사용자와 시스템 인터페이스를 위한 또 다른 계층 하나를 반드시 포함한다.

이들 아키텍처는 모두 시스템이 다음과 같은 특징을 지니도록 만든다.

- 프레임워크 독립성: 프레임워크가 지닌 제약사항안으로 시스템을 욱여넣지 않도록 한다.
- 테스트 용이성: 업무 규칙은 UI, DB, 웹 서버 또는 여타 외부 요소 없이도 테스트할 수 있다.
- UI 독립성: 시스템에 나머지 부분을 변경하지 않고도 UI를 쉽게 변경할 수 있다.
- DB 독립성: 업무 규칙은 DB에 결합되지 않는다.
- 모든 외부 에이전시에 대한 독립성: 업무 규칙은 외부 세계와의 인터페이스에 대해 전혀 알지 못한다.

### 의존성

---

클린 아키텍처의 동심원은 소프트웨어에서 서로 다른 영역을 표현한다. 보통 안으로 들어갈수록 고수준의 소프트웨어가 된다. 이러한 아키텍처가 동작하도록 가장 중요한 규칙은 의존성 규칙으로, 소스 코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.

### 엔티티

---

클린 아키텍처에서 엔티티는 전사적인 핵심 업무 규칙을 캡슐화한다. 엔티티는 메서드를 가지는 객체이거나 일련의 데이터 구조와 함수의 집합일 수도 있다. 기업의 다양한 애플리케이션에서 엔티티를 재사용할 수만 있다면, 그 형태는 중요하지 않다.

### 유스케이스

---

유스케이스 계층의 소프트웨어는 애플리케이션에 특화된 업무 규칙을 포함한다. 유스케이스는 엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 자신의 핵심 업무 규칙을 사용해서 유스케이스의 목적을 달성하도록 이끈다.

원들은 그저 개념을 설명하기 위한 예시일뿐 네 개보다 더 많은 원이 필요할 수도 있다. 단지 어떠한 경우에도 의존성 규칙은 지켜져야 한다. 따라서 가장 안쪽 원은 가장 범용적이며 높은 수준을 가진다.

경계를 횡단할 때 데이터 구조는 간단하게 이루어져 있다. 기본적인 구조체나 DTO등 원하는 대로 고를 수 있고, 간단한 인자를 사용해서 데이터로 전달할 수도 있다. 중요한 점은 격리되어 있는 간단한 데이터 구조가 경계를 가로질러 전달된다는 사실이다. 하지만 DB의 행 구조가 경계를 넘어 내부로 그대로 전달되면 내부의 원에서 외부의 원의 무언가를 알아야만 하기 때문에 의존성 규칙을 위배하게 된다. 따라서 경계를 가로질러 데이터를 전달할 때, 데이터는 항상 내부의 원에서 사용하기에 가장 편리한 형태를 가져야 한다.

소프트웨어를 계층으로 분리하고 의존성 규칙을 준수한다면 본질적으로 테스트하기 쉬운 시스템을 만들게 될 것이며, 그에 따른 이점을 누릴 수 있다.